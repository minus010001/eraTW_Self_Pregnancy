;OBJ存在設定関数
@SETLIST_EXIST(CLASS_NAME, O_FIRST = OBJ_ID_FIRST, O_LAST = OBJ_ID_LAST)
#DIMS CLASS_NAME
#DIM O_FIRST
#DIM O_LAST
#DIM O_ID
;変数名F_NAMEを作成する
CALLF MAKE_EXIST(CLASS_NAME)

FOR O_ID, O_FIRST, O_LAST + 1
	;個々のF_NAME:LCOUNTを設定する
	TRYCCALLFORM EXIST_%CLASS_NAME%{O_ID}
		;DEBUGPRINTFORML EXIST %CLASS_NAME%{O_ID}
		CALLF SET_EXIST(CLASS_NAME, O_ID)
	CATCH
	ENDCATCH
NEXT

;ID取得関数用の設定を行う
TRYCCALLFORM EXIST_%CLASS_NAME%_ID
	;DEBUGPRINTFORML EXIST %CLASS_NAME%NAME_TO_ID
	CALLF OBJNAME_TO_ID(, "RESET", CLASS_NAME)
CATCH
ENDCATCH


;関数の存在判定用関数群
;変数の擬似定義
@MAKE_EXIST(CLASS_NAME)
#FUNCTION
#DIMS CLASS_NAME
RETURNF OBJ_EXIST("MAKE", CLASS_NAME)

;個々の関数の存在判定を設定
;先にCF_MAKEが必要
@SET_EXIST(CLASS_NAME, O_ID)
#FUNCTION
#DIMS CLASS_NAME
#DIM  O_ID
RETURNF OBJ_EXIST("SET", CLASS_NAME, O_ID)

;個々のINDEXの存在判定
@GET_EXIST(CLASS_NAME, O_ID)
#FUNCTION
#DIMS CLASS_NAME
#DIM  O_ID
RETURNF OBJ_EXIST("GET", CLASS_NAME, O_ID)



;OBJの存在状態の保持関数
;
;ほぼ一時変数保持変数の流用で一次元配列から二次元配列にしただけ
;CLEAR系命令がないので誤消去の心配はない
@OBJ_EXIST(COMMAND, ARGS:0, ARG:0)
#FUNCTION
#DIMS CLASS_NAME, CLASS_NUM + 1
#DIMS COMMAND
#DIM EXIST, CLASS_NUM + 1, OBJ_ID_LAST + 1
#DIM OBJ_CNT
SELECTCASE COMMAND
;変数の擬似定義
CASE "MAKE"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	SIF FINDELEMENT(CLASS_NAME, ESCAPE(ARGS:0) , 1, , 1) > 0
		THROW すでに設定済みの変数です%ARGS:0%
	SIF OBJ_CNT == CLASS_NUM
		THROW 保持変数が上限に達しています
	OBJ_CNT ++
	CLASS_NAME:(OBJ_CNT) = %ARGS:0%
;個々の変数の設定
CASE "SET"
	SIF !INRANGE(ARG:0, OBJ_ID_FIRST, OBJ_ID_LAST)
		THROW 配列の範囲外です{ARG}
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	LOCAL:0 = FINDELEMENT(CLASS_NAME, ESCAPE(ARGS:0) , 1, , 1)
	SIF LOCAL:0 < 0
		THROW 未設定の変数です%ARGS:0%
	EXIST:(LOCAL:0):(ARG:0) = 1
;各関数の有無判定
CASE "GET"
	SIF !INRANGE(ARG:0, OBJ_ID_FIRST, OBJ_ID_LAST)
		THROW 配列の範囲外です{ARG}
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	LOCAL:0 = FINDELEMENT(CLASS_NAME, ESCAPE(ARGS:0) , 1, , 1)
	SIF LOCAL:0 < 0
		THROW 未設定の変数です%ARGS:0%
	RETURNF EXIST:(LOCAL:0):(ARG:0)
CASEELSE
	THROW 未設定命令%COMMAND%
ENDSELECT
